<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>H·ªçc H√¨nh H·ªçc 3D (AR Hand Tracking)</title>
    
    <link rel="icon" href="data:,">

    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        /* --- CSS GIAO DI·ªÜN --- */
        body { margin: 0; font-family: 'Segoe UI', sans-serif; overflow: hidden; display: flex; height: 100vh; background-color: #f5f6fa; }
        
        body.in-ar #sidebar, 
        body.in-ar #text-panel, 
        body.in-ar #cam-toggle, 
        body.in-ar #mobile-toggle, 
        body.in-ar #animation-controls,
        body.in-ar #loading { display: none !important; }
        
        body.in-ar #main-content { background: transparent !important; }
        body.in-ar #viewer-container { background: transparent !important; border: none !important; }

        #ar-ui-overlay {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            pointer-events: none; 
            z-index: 10000; 
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 20px;
        }
        
        body.in-ar #ar-ui-overlay { display: flex; } 

        .ar-btn-group {
            display: flex;
            align-items: center;
            gap: 20px;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.15); 
            padding: 10px 25px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        #btn-place-ar {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 15px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #btn-place-ar:active { transform: scale(0.95); }

        .ar-scale-btn {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            user-select: none;
        }
        .ar-scale-btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.9); }

        #ar-button {
            position: absolute !important;
            top: 20px !important;     
            left: 20px !important;    
            bottom: auto !important; right: auto !important;
            width: auto !important; padding: 8px 16px !important;
            opacity: 0.9 !important; border-radius: 20px !important;
            z-index: 99999 !important; font-size: 13px !important; font-weight: bold !important;
        }
        @media (min-width: 1024px) { #ar-button { display: none !important; } }

        /* --- CSS C≈® --- */
        #sidebar { width: 280px; background-color: #2c3e50; color: white; display: flex; flex-direction: column; border-right: 1px solid #ddd; flex-shrink: 0; z-index: 200; overflow-y: auto; }
        .brand { padding: 20px; font-size: 18px; font-weight: bold; background: #1a252f; text-align: center; border-bottom: 1px solid #34495e; }
        ul { list-style: none; padding-left: 0; margin: 0; }
        .menu-folder-title { padding: 12px 15px; cursor: pointer; background: #34495e; border-bottom: 1px solid #2c3e50; display: flex; justify-content: space-between; font-weight: 600; font-size: 14px; }
        .menu-folder-title:hover { background: #3e5871; }
        .submenu { display: none; background: #233140; }
        .submenu.show { display: block; }
        .submenu .menu-folder-title { padding-left: 30px; } 
        .menu-item { padding: 10px 15px 10px 30px; cursor: pointer; color: #bdc3c7; font-size: 14px; border-left: 4px solid transparent; display: block; }
        .submenu .menu-item { padding-left: 45px; }
        .menu-item:hover { color: white; background: rgba(255,255,255,0.05); }
        .menu-item.active { background: #3498db; color: white; border-left: 4px solid #fff; }
        .sidebar-footer { padding: 15px; text-align: center; color: #aaa; font-size: 12px; margin-top: auto; }
        
        #main-content { flex: 1; display: flex; position: relative; overflow: hidden; }
        #viewer-container { flex: 7; position: relative; background: #e0e0e0; overflow: hidden; border-right: 2px solid #ccc; transition: background 0.3s; }
        #text-panel { flex: 3; display: flex; flex-direction: column; min-width: 300px; background: white; border-left: 1px solid #ccc; }
        #problem-section { flex: 1; display: flex; flex-direction: column; border-bottom: 4px double #ddd; background-color: #fffdf5; }
        .section-header { padding: 8px 15px; font-weight: bold; font-size: 14px; color: white; display: flex; justify-content: space-between; align-items: center; }
        .header-problem { background: #f39c12; }
        .header-solution { background: #3498db; }
        .section-content { padding: 15px; overflow-y: auto; font-size: 14px; line-height: 1.6; color: #333; white-space: pre-wrap; flex: 1; }
        #solution-section { flex: 3; display: flex; flex-direction: column; position: relative; background: white; }
        #solution-content-wrapper { flex: 1; overflow-y: auto; position: relative; padding: 15px; }
        #solution-text { font-size: 14px; line-height: 1.6; transition: filter 0.3s; white-space: pre-wrap; }
        .blur-solution { filter: blur(10px); user-select: none; pointer-events: none; opacity: 0.5; }
        #reveal-btn { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 20px; font-weight: bold; cursor: pointer; z-index: 10; box-shadow: 0 4px 10px rgba(0,0,0,0.2); display: none; }
        #reveal-btn:hover { background: #2ecc71; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 15px 30px; border-radius: 30px; display: none; pointer-events: none; z-index: 100; }
        
        #cam-toggle { position: absolute; top: 20px; right: 20px; z-index: 100; background: white; border: 1px solid #ccc; width: 40px; height: 40px; border-radius: 8px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); font-size: 20px; display: flex; justify-content: center; align-items: center; transition: 0.2s; }
        #cam-toggle:hover { transform: scale(1.1); background: #f0f0f0; }
        
        #animation-controls { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.95); padding: 8px 15px; border-radius: 50px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; align-items: center; gap: 15px; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #animation-controls.visible { opacity: 1; pointer-events: auto; }
        .control-btn { background: #2c3e50; color: white; border: none; width: 35px; height: 35px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; justify-content: center; align-items: center; transition: 0.2s; }
        .control-btn:hover { background: #3498db; }
        .control-btn:disabled { background: #ccc; cursor: not-allowed; }
        #step-indicator { font-weight: bold; color: #2c3e50; font-size: 14px; min-width: 70px; text-align: center; }
        
        @media (max-width: 768px) { #sidebar { position: absolute; height: 100%; transform: translateX(-100%); } #sidebar.mobile-open { transform: translateX(0); } #main-content { flex-direction: column; } #viewer-container { flex: 1; height: 50%; } #text-panel { flex: 1; height: 50%; } #cam-toggle { top: 60px; } }
        #mobile-toggle { display: none; position: absolute; top: 10px; right: 10px; z-index: 100; background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; }
        @media (max-width: 768px) { #mobile-toggle { display: block; } }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="brand">üìê MENU B√ÄI T·∫¨P</div>
        <div id="menu-content"></div>
        <div class="sidebar-footer">V46 - FINAL VIEW & SCALE</div>
    </div>

    <div id="main-content">
        <div id="viewer-container">
            <button id="mobile-toggle">‚ò∞ Menu</button>
            <div id="loading">‚è≥ ƒêang t·∫£i...</div>
            <button id="cam-toggle" title="Chuy·ªÉn View" onclick="toggleCamera()">üßä</button>
            <div id="animation-controls">
                <button class="control-btn" id="btn-prev" title="L√πi">‚ùÆ</button>
                <div id="step-indicator">B·∫Øt ƒë·∫ßu</div>
                <button class="control-btn" id="btn-next" title="Ti·∫øp">‚ùØ</button>
            </div>
            
            <div id="ar-ui-overlay">
                <div class="ar-btn-group">
                    <div class="ar-scale-btn" id="btn-scale-down" title="Thu nh·ªè">‚àí</div>
                    <div id="btn-place-ar">üëá ƒê·∫∂T M√î H√åNH</div>
                    <div class="ar-scale-btn" id="btn-scale-up" title="Ph√≥ng to">+</div>
                </div>
            </div>

        </div>

        <div id="text-panel">
            <div id="problem-section">
                <div class="section-header header-problem">üìÑ ƒê·ªÅ B√†i</div>
                <div class="section-content" id="problem-text"><i>Ch·ªçn b√†i t·∫≠p t·ª´ menu...</i></div>
            </div>
            <div id="solution-section">
                <div class="section-header header-solution">
                    <span>üí° L·ªùi Gi·∫£i</span>
                    <button onclick="toggleSolution()" style="background:none; border:1px solid rgba(255,255,255,0.5); color:white; border-radius:4px; cursor:pointer; font-size:11px; padding:2px 6px;">·∫®n/Hi·ªán</button>
                </div>
                <div id="solution-content-wrapper">
                    <button id="reveal-btn" onclick="toggleSolution()">üëÅÔ∏è Xem L·ªùi Gi·∫£i</button>
                    <div id="solution-text" class="blur-solution"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="menu_data.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- C·∫§U H√åNH ---
        const SHOW_SHADOW = true; 

        // --- SETUP ---
        const viewer = document.getElementById('viewer-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);

        const aspect = viewer.clientWidth / viewer.clientHeight;
        
        const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10000);
        const perspCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 10000);
        let activeCamera = orthoCamera; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewer.clientWidth, viewer.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio); 
        renderer.sortObjects = true;
        renderer.xr.enabled = true; 
        renderer.setClearColor(0x000000, 0); 
        viewer.appendChild(renderer.domElement);

        const controls = new OrbitControls(activeCamera, renderer.domElement);
        controls.enableDamping = true; controls.enableRotate = true;
        const clock = new THREE.Clock();

        // --- AR & HAND TRACKING VARS ---
        let textLabels = []; 
        let currentShadow = null;
        let arScale = 0.08; // M·∫∑c ƒë·ªãnh nh·ªè h∆°n ƒë·ªÉ v·ª´a tay (kho·∫£ng 8cm)
        const minScale = 0.02; 
        const maxScale = 2.0; 

        // Hand Controllers
        const hand0 = renderer.xr.getHand(0);
        const hand1 = renderer.xr.getHand(1);
        scene.add(hand0);
        scene.add(hand1);

        // --- SHADER MATERIALS ---
        function getColorFromName(name) {
            const n = name.toLowerCase();
            if (n.includes('red')) return 0xff4444; if (n.includes('green')) return 0x22aa22;
            if (n.includes('blue')) return 0x4444ff; if (n.includes('yellow')) return 0xffaa00;
            return null; 
        }

        function createMaterials(colorHex, sizeFactor = 1) {
            let faceC = 0xcccccc; let lineC = 0x000000; let hiddenC = 0x888888;
            if (colorHex !== null) { faceC = colorHex; lineC = colorHex; hiddenC = colorHex; }
            
            const myDash = sizeFactor / 30; 
            const myGap = myDash / 2;

            return {
                face: new THREE.MeshBasicMaterial({ color: faceC, side: THREE.DoubleSide, polygonOffset: true, polygonOffsetFactor: 0.75, polygonOffsetUnits: 1, depthWrite: true, transparent: true, opacity: 0.8 }),
                hidden: new THREE.LineDashedMaterial({ color: hiddenC, dashSize: myDash, gapSize: myGap, depthTest: true, depthFunc: THREE.GreaterDepth, transparent: true, opacity: 1, polygonOffset: false }),
                visible: new THREE.LineBasicMaterial({ color: lineC, depthTest: true, depthFunc: THREE.LessEqualDepth, transparent: true, polygonOffset: true, polygonOffsetFactor: -0.75, polygonOffsetUnits: -1 }),
                fixedDashed: new THREE.LineDashedMaterial({
                    color: (colorHex !== null) ? colorHex : 0x000000, 
                    dashSize: myDash, gapSize: myGap, depthTest: true, depthFunc: THREE.LessEqualDepth, transparent: true, opacity: 1
                })
            };
        }

        const symbolMaterial = new THREE.LineBasicMaterial({ color: 0x000000, depthTest: false, depthWrite: false, transparent: true, opacity: 1 });
        
        function manualComputeLineDistances(geometry) {
            const pos = geometry.attributes.position; const lineDistances = new Float32Array(pos.count); const p1 = new THREE.Vector3(), p2 = new THREE.Vector3();
            for (let i = 0; i < pos.count; i += 2) { p1.fromBufferAttribute(pos, i); p2.fromBufferAttribute(pos, i + 1); lineDistances[i] = 0; lineDistances[i+1] = p1.distanceTo(p2); }
            geometry.setAttribute('lineDistance', new THREE.BufferAttribute(lineDistances, 1));
        }

        // --- AR BUTTON (C·∫¨P NH·∫¨T: Th√™m hand-tracking) ---
        const arBtnDOM = ARButton.createButton(renderer, { 
            requiredFeatures: ['hit-test'],
            // Y√™u c·∫ßu th√™m 'hand-tracking'
            optionalFeatures: ['dom-overlay', 'hand-tracking'], 
            domOverlay: { root: document.body } 
        });
        arBtnDOM.id = "ar-button"; 
        document.body.appendChild(arBtnDOM);

        // KHI V√ÄO AR
        renderer.xr.addEventListener('sessionstart', () => {
            document.body.classList.add('in-ar');
            scene.background = null; 
            if(currentModel) {
                currentModel.visible = false; 
                arScale = 0.08; // Set scale nh·ªè h∆°n khi v√†o AR ƒë·ªÉ v·ª´a tay
                currentModel.scale.set(arScale, arScale, arScale);
                if(currentShadow) currentShadow.visible = SHOW_SHADOW;
            }
        });

        // KHI THO√ÅT AR
        renderer.xr.addEventListener('sessionend', () => {
            document.body.classList.remove('in-ar');
            scene.background = new THREE.Color(0xe0e0e0);
            if(currentModel) {
                currentModel.visible = true; 
                currentModel.scale.set(1,1,1);
                currentModel.position.set(0,0,0);
                if(currentShadow) currentShadow.visible = false;
            }
            activeCamera.position.set(0, 2, 10);
            activeCamera.lookAt(0,0,0);
        });

        const reticle = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2), new THREE.MeshBasicMaterial());
        reticle.matrixAutoUpdate = false; reticle.visible = false;
        scene.add(reticle);

        let hitTestSource = null;
        let hitTestSourceRequested = false;

        // --- UI EVENTS ---
        document.getElementById('btn-place-ar').addEventListener('click', (e) => {
            e.stopPropagation(); 
            // N·∫øu kh√¥ng d√πng tay th√¨ m·ªõi d√πng reticle
            if (reticle.visible && currentModel) {
                currentModel.position.setFromMatrixPosition(reticle.matrix);
                currentModel.visible = true;
                // Khi ƒë·∫∑t b·∫±ng tay ch·∫°m, set scale v·ªÅ full arScale
                currentModel.scale.set(arScale, arScale, arScale);
            }
        });

        function updateARScale() {
            if(currentModel && document.body.classList.contains('in-ar')) {
                // Ch·ªâ c·∫≠p nh·∫≠t bi·∫øn, vi·ªác scale model s·∫Ω do logic Hand Tracking x·ª≠ l√Ω
            }
        }
        document.getElementById('btn-scale-up').addEventListener('click', (e) => {
            e.stopPropagation();
            if (arScale < maxScale) { arScale += 0.05; }
        });
        document.getElementById('btn-scale-down').addEventListener('click', (e) => {
            e.stopPropagation();
            if (arScale > minScale) { arScale -= 0.01; }
        });


        // --- HELPER FUNCTIONS ---
        function createTextSprite(message) {
            const ctx = document.createElement('canvas').getContext('2d');
            const size = 64; 
            ctx.canvas.width = size * 4; 
            ctx.canvas.height = size * 2;
            ctx.font = `Bold ${size}px "Times New Roman", serif`;
            ctx.fillStyle = "rgba(0, 0, 0, 1.0)";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom"; 
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 6;
            ctx.strokeText(message, ctx.canvas.width / 2, ctx.canvas.height - 10);
            ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height - 10);
            const texture = new THREE.CanvasTexture(ctx.canvas);
            texture.minFilter = THREE.LinearFilter;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.renderOrder = 9999; 
            sprite.center.set(0.5, 0); 
            return sprite;
        }

        function createSoftShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(64, 64, 10, 64, 64, 60);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function createShadowPlane(size) {
            const geometry = new THREE.PlaneGeometry(size * 1.5, size * 1.5);
            const texture = createSoftShadowTexture();
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, opacity: 1, side: THREE.DoubleSide, depthWrite: false
            });
            const shadow = new THREE.Mesh(geometry, material);
            shadow.rotation.x = -Math.PI / 2; 
            shadow.position.y = 0.005; 
            shadow.renderOrder = 0;
            return shadow;
        }

        window.toggleCamera = function() {
            const btn = document.getElementById('cam-toggle');
            const oldPos = activeCamera.position.clone();
            const oldTarget = controls.target.clone();
            if (activeCamera === orthoCamera) {
                activeCamera = perspCamera; btn.innerHTML = "üëÅÔ∏è"; btn.title = "ƒêang xem: Ph·ªëi c·∫£nh";
                activeCamera.position.copy(oldPos); activeCamera.lookAt(oldTarget);
            } else {
                activeCamera = orthoCamera; btn.innerHTML = "üßä"; btn.title = "ƒêang xem: Tr·ª•c ƒëo";
                activeCamera.position.copy(oldPos); activeCamera.lookAt(oldTarget); activeCamera.zoom = 1; activeCamera.updateProjectionMatrix();
            }
            controls.object = activeCamera; controls.target.copy(oldTarget); controls.update();
        }

        window.toggleSolution = function() {
            const textDiv = document.getElementById('solution-text');
            const btn = document.getElementById('reveal-btn');
            if (textDiv.classList.contains('blur-solution')) { textDiv.classList.remove('blur-solution'); btn.style.display = 'none'; } else { textDiv.classList.add('blur-solution'); btn.style.display = 'block'; }
        }

        let mixer = null; let animationActions = []; let currentStepIndex = -1; let currentModel = null;
        const controlsPanel = document.getElementById('animation-controls');
        const btnPrev = document.getElementById('btn-prev');
        const btnNext = document.getElementById('btn-next');
        const stepIndicator = document.getElementById('step-indicator');

        function updateStepVisibility(currentStep) {
            if (!currentModel) return;
            currentModel.children[0].traverse((child) => {
                const match = child.name.match(/step_(\d+)/i);
                if (match) { child.visible = (parseInt(match[1]) <= currentStep + 1); }
            });
        }
        function updateUI() {
            if (animationActions.length === 0) { controlsPanel.classList.remove('visible'); return; }
            controlsPanel.classList.add('visible');
            const displayStep = currentStepIndex + 1;
            stepIndicator.innerText = displayStep === 0 ? "B·∫Øt ƒë·∫ßu" : `B∆∞·ªõc ${displayStep}/${animationActions.length}`;
            btnPrev.disabled = currentStepIndex < 0; btnNext.disabled = currentStepIndex >= animationActions.length - 1;
        }
        btnNext.addEventListener('click', () => { if (currentStepIndex < animationActions.length - 1) { currentStepIndex++; const action = animationActions[currentStepIndex]; action.reset(); action.setLoop(THREE.LoopOnce); action.clampWhenFinished = true; action.play(); updateStepVisibility(currentStepIndex); updateUI(); } });
        btnPrev.addEventListener('click', () => { if (currentStepIndex >= 0) { const action = animationActions[currentStepIndex]; action.stop(); currentStepIndex--; updateStepVisibility(currentStepIndex); updateUI(); } });

        // --- HAND TRACKING LOGIC ---
        function updateHandTrackingLogic() {
            if (!renderer.xr.isPresenting || !currentModel) return;

            const hands = [hand0, hand1];
            let foundOpenHand = false;
            let handDetected = false;

            for (const hand of hands) {
                // Ki·ªÉm tra xem tay c√≥ kh·ªõp kh√¥ng
                if (hand.joints && hand.joints['wrist'] && hand.joints['middle-finger-tip']) {
                    handDetected = true;
                    const wrist = hand.joints['wrist'];
                    const middleTip = hand.joints['middle-finger-tip'];
                    const indexTip = hand.joints['index-finger-tip'];

                    // T√≠nh kho·∫£ng c√°ch c·ªï tay - ƒë·∫ßu ng√≥n gi·ªØa
                    const distance = wrist.position.distanceTo(middleTip.position);
                    
                    // Ng∆∞·ª°ng ph√°t hi·ªán m·ªü tay (0.12 m√©t = 12cm)
                    if (distance > 0.12) {
                        foundOpenHand = true;
                        
                        // DI CHUY·ªÇN MODEL THEO TAY (Gi·ªØa l√≤ng b√†n tay)
                        const palmPos = new THREE.Vector3().copy(wrist.position).lerp(middleTip.position, 0.4);
                        currentModel.position.lerp(palmPos, 0.2); // Di chuy·ªÉn m∆∞·ª£t
                        currentModel.quaternion.slerp(wrist.quaternion, 0.1); // Xoay theo tay

                        // ·∫®n Reticle (v√≤ng tr√≤n d√≤ s√†n) khi d√πng tay
                        reticle.visible = false;
                        break; 
                    }
                }
            }

            // X·ª¨ L√ù SCALE (HI·ªÜU ·ª®NG PH√ìNG TO/THU NH·ªé)
            // N·∫øu c√≥ tay detect:
            // - M·ªü tay: Scale = arScale
            // - N·∫Øm tay: Scale = 0
            // N·∫øu KH√îNG c√≥ tay detect (d√πng ƒëi·ªán tho·∫°i th∆∞·ªùng): Gi·ªØ nguy√™n scale hi·ªán t·∫°i ƒë·ªÉ d√πng Touch
            
            if (handDetected) {
                const targetScale = foundOpenHand ? arScale : 0;
                const smoothing = 0.15;
                const currentS = currentModel.scale.x;
                
                if (Math.abs(currentS - targetScale) > 0.001) {
                    const newS = THREE.MathUtils.lerp(currentS, targetScale, smoothing);
                    currentModel.scale.set(newS, newS, newS);
                    currentModel.visible = true;
                } else if (targetScale === 0) {
                    currentModel.visible = false;
                }
            } else {
                // Fallback: N·∫øu kh√¥ng th·∫•y tay, ƒë·∫£m b·∫£o model v·∫´n scale ƒë√∫ng theo arScale (cho ch·∫ø ƒë·ªô ch·∫°m m√†n h√¨nh)
                if (currentModel.visible) {
                   const currentS = currentModel.scale.x;
                   if (Math.abs(currentS - arScale) > 0.001) {
                       currentModel.scale.set(arScale, arScale, arScale);
                   }
                }
            }
        }

        // --- LOAD MODEL ---
        const loader = new GLTFLoader();

        window.loadModel3D = function(filePath, title, fullTextFromMenu) {
            const loading = document.getElementById('loading'); 
            loading.style.display = 'block';
            
            const problemDiv = document.getElementById('problem-text'); 
            const solutionDiv = document.getElementById('solution-text');
            
            solutionDiv.classList.add('blur-solution'); 
            document.getElementById('reveal-btn').style.display = 'block';
            problemDiv.innerHTML = "<i>‚è≥ ƒêang t·∫£i ƒë·ªÅ b√†i...</i>"; 
            solutionDiv.innerHTML = "";

            if (currentModel) { scene.remove(currentModel); currentModel = null; currentShadow = null; }
            textLabels = [];

            if (mixer) { mixer.stopAllAction(); mixer = null; }
            animationActions = []; currentStepIndex = -1; controlsPanel.classList.remove('visible');

            const timestamp = new Date().getTime();
            const encodedPath = encodeURI(filePath); 
            const textPathRaw = filePath.replace('.glb', '.txt').replace('.gltf', '.txt');
            const encodedTextPath = encodeURI(textPathRaw);

            fetch(encodedTextPath + '?t=' + timestamp)
                .then(response => { if (!response.ok) throw new Error("File text kh√¥ng t·ªìn t·∫°i"); return response.text(); })
                .then(text => {
                    const parts = text.split('====='); 
                    problemDiv.innerHTML = parts[0].trim(); 
                    solutionDiv.innerHTML = parts.length > 1 ? parts.slice(1).join('=====').trim() : "<i>(Ch∆∞a c√≥ l·ªùi gi·∫£i chi ti·∫øt)</i>"; 
                    if (window.MathJax) MathJax.typesetPromise([problemDiv, solutionDiv]).then(()=>{});
                })
                .catch(err => {
                    if (fullTextFromMenu) {
                        const parts = fullTextFromMenu.split('=====');
                        problemDiv.innerHTML = parts[0].trim();
                        solutionDiv.innerHTML = parts.length > 1 ? parts.slice(1).join('=====').trim() : "<i>(Ch∆∞a c√≥ l·ªùi gi·∫£i chi ti·∫øt)</i>";
                        if (window.MathJax) MathJax.typesetPromise([problemDiv, solutionDiv]).then(()=>{});
                    } else { problemDiv.innerHTML = "<i>(Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ƒë·ªÅ b√†i)</i>"; }
                });

            loader.load(encodedPath + '?t=' + timestamp, (gltf) => {
                const rawScene = gltf.scene; 

                // --- SMART BOX CALCULATION ---
                let smartBox = new THREE.Box3();
                let hasMesh = false;
                rawScene.traverse((child) => {
                    if (child.isMesh) {
                        if (!child.geometry.boundingBox) child.geometry.computeBoundingBox();
                        const childBox = child.geometry.boundingBox.clone();
                        childBox.applyMatrix4(child.matrixWorld);
                        smartBox.union(childBox);
                        hasMesh = true;
                    }
                });
                if (!hasMesh) smartBox.setFromObject(rawScene);

                const center = smartBox.getCenter(new THREE.Vector3());
                const size = smartBox.getSize(new THREE.Vector3());

                // --- CONTAINER SETUP ---
                const container = new THREE.Group();
                rawScene.position.x = -center.x;
                rawScene.position.y = -smartBox.min.y; 
                rawScene.position.z = -center.z;
                
                const maxDim = Math.max(size.x, size.y, size.z) || 1;
                const normScale = 1.0 / maxDim; 
                
                // L∆∞u l·∫°i scale ƒë·ªÉ d√πng cho label
                container.userData.normScale = normScale;
                
                rawScene.scale.setScalar(normScale); 

                container.add(rawScene);

                if (SHOW_SHADOW) {
                    currentShadow = createShadowPlane(1.0); 
                    currentShadow.visible = false; 
                    container.add(currentShadow);
                }

                if (gltf.animations && gltf.animations.length > 0) { mixer = new THREE.AnimationMixer(rawScene); const clips = gltf.animations.sort((a, b) => a.name.localeCompare(b.name)); clips.forEach(clip => { const action = mixer.clipAction(clip); animationActions.push(action); }); updateUI(); }

                rawScene.traverse((child) => {
                    if (child.userData.isGenerated) return;
                    
                    if (child.name.includes("Label_")) { 
                        child.scale.set(1, 1, 1);
                        child.updateMatrixWorld(); 
                        const match = child.name.match(/\((.*?)\)/); 
                        let displayText = match ? match[1] : child.name.replace("Label_", "").split(".")[0]; 
                        const sprite = createTextSprite(displayText);
                        sprite.position.set(0, 0.02 / normScale, 0); 
                        child.add(sprite); 
                        textLabels.push(sprite);
                        if(child.material) child.material.visible = false; 
                    }
                    else if (child.name.includes("Symbol")) { 
                        if(child.isLine || child.isLineSegments) { child.material = symbolMaterial; child.renderOrder = 999; child.userData.isGenerated = true; } 
                    }
                    else if (child.name.includes("DASH")) {
                        if(child.isLine || child.isLineSegments) {
                            const color = getColorFromName(child.name);
                            const myMats = createMaterials(color, maxDim); 
                            manualComputeLineDistances(child.geometry);
                            child.material = myMats.fixedDashed; 
                            child.renderOrder = 1;
                            child.userData.isGenerated = true; 
                        }
                    }
                    else if (child.isMesh) { 
                        const color = getColorFromName(child.name); const myMats = createMaterials(color, maxDim); child.material = myMats.face; child.renderOrder = 0; const edgesGeom = new THREE.EdgesGeometry(child.geometry, 15); const lHidden = new THREE.LineSegments(edgesGeom, myMats.hidden); lHidden.computeLineDistances(); lHidden.renderOrder = 1; lHidden.userData.isGenerated = true; const lVisible = new THREE.LineSegments(edgesGeom, myMats.visible); lVisible.renderOrder = 1; lVisible.userData.isGenerated = true; child.add(lHidden); child.add(lVisible); 
                    } 
                    else if (child.isLine || child.isLineSegments) { 
                        const color = getColorFromName(child.name); const myMats = createMaterials(color, maxDim); manualComputeLineDistances(child.geometry); child.material = myMats.visible; child.renderOrder = 1; const hiddenClone = child.clone(); hiddenClone.position.set(0,0,0); hiddenClone.rotation.set(0,0,0); hiddenClone.scale.set(1,1,1); hiddenClone.quaternion.set(0,0,0,1); hiddenClone.material = myMats.hidden; hiddenClone.renderOrder = 1; hiddenClone.userData.isGenerated = true; child.add(hiddenClone); 
                    }
                });

                currentModel = container;
                updateStepVisibility(-1);
                
                // --- FIX CAMERA POSITIONS ---
                const targetCenter = new THREE.Vector3(0, 0.5, 0); 
                
                const orthoPadding = 1.0; 
                orthoCamera.left = -orthoPadding * aspect;
                orthoCamera.right = orthoPadding * aspect;
                orthoCamera.top = orthoPadding; 
                orthoCamera.bottom = -orthoPadding;
                orthoCamera.updateProjectionMatrix();
                orthoCamera.position.set(2, 2, 2); 
                orthoCamera.lookAt(targetCenter);
                
                perspCamera.position.set(1.8, 1.5, 2.5); 
                perspCamera.lookAt(targetCenter);
                
                scene.add(currentModel); 
                
                controls.object = activeCamera; 
                controls.target.copy(targetCenter); 
                controls.update(); 
                
                loading.style.display = 'none';

            }, undefined, (err) => { console.error(err); loading.style.display = 'none'; alert("L·ªói t·∫£i file 3D"); });
        }

        // --- MAIN LOOP ---
        function render(timestamp, frame) {
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);

            // C·∫≠p nh·∫≠t Logic Hand Tracking
            updateHandTrackingLogic();

            if (textLabels.length > 0) {
                const normScale = currentModel ? (currentModel.userData.normScale || 1.0) : 1.0;

                if (renderer.xr.isPresenting) {
                    // *** FIX AR SCALE LABEL ***
                    const arBase = 0.08; 
                    const tempVec = new THREE.Vector3();
                    const xrCamera = renderer.xr.getCamera(activeCamera);

                    textLabels.forEach(sprite => {
                        sprite.getWorldPosition(tempVec);
                        const distance = tempVec.distanceTo(xrCamera.position); 
                        const s = (distance * arBase) / normScale; 
                        sprite.scale.set(s * 2, s, 1);
                    });
                } 
                else {
                    // *** PC / MOBILE VIEW ***
                    if (activeCamera.isPerspectiveCamera) {
                        const pcBase = 0.035; 
                        const tempVec = new THREE.Vector3();
                        textLabels.forEach(sprite => {
                            const parentWorldScale = sprite.parent.getWorldScale(new THREE.Vector3()).x; 
                            sprite.getWorldPosition(tempVec);
                            const distance = tempVec.distanceTo(activeCamera.position);
                            const s = (distance * pcBase) / parentWorldScale;
                            sprite.scale.set(s * 2, s, 1); 
                        });
                    } else if (activeCamera.isOrthographicCamera) {
                        const orthoBase = 0.08; 
                        textLabels.forEach(sprite => {
                            const parentWorldScale = sprite.parent.getWorldScale(new THREE.Vector3()).x;
                            const s = (orthoBase / activeCamera.zoom) / parentWorldScale; 
                            sprite.scale.set(s * 2, s, 1);
                        });
                    }
                }
            }
            
            if (frame) {
                // Logic Hit Test (Gi·ªØ l·∫°i ƒë·ªÉ d√≤ s√†n n·∫øu kh√¥ng d√πng tay)
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', function () {
                        hitTestSourceRequested = false; hitTestSource = null; reticle.visible = false;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource && reticle.visible !== false) { // Ch·ªâ d√≤ s√†n n·∫øu Reticle ch∆∞a b·ªã t·∫Øt b·ªüi Hand Tracking
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else { reticle.visible = false; }
                }
            }

            controls.update();
            renderer.render(scene, activeCamera);
        }

        renderer.setAnimationLoop(render);

        window.addEventListener('resize', () => {
            const w = viewer.clientWidth; const h = viewer.clientHeight; const newAspect = w / h;
            perspCamera.aspect = newAspect; perspCamera.updateProjectionMatrix();
            const currentFrustumHeight = (orthoCamera.top - orthoCamera.bottom);
            orthoCamera.left = -currentFrustumHeight * newAspect / 2; orthoCamera.right = currentFrustumHeight * newAspect / 2; orthoCamera.top = currentFrustumHeight / 2; orthoCamera.bottom = -currentFrustumHeight / 2; orthoCamera.updateProjectionMatrix();
            renderer.setSize(w, h); 
        });

        const menuContainer = document.getElementById('menu-content');
        function createMenuHTML(data, parentElement) {
            const ul = document.createElement('ul'); if (parentElement !== menuContainer) ul.classList.add('submenu');
            data.forEach(item => { const li = document.createElement('li'); if (item.type === 'folder') { const titleDiv = document.createElement('div'); titleDiv.className = 'menu-folder-title'; titleDiv.innerHTML = `<span>${item.title}</span> <span>‚ñ∂</span>`; titleDiv.onclick = () => { const sub = li.querySelector('.submenu'); if (sub) sub.classList.toggle('show'); }; li.appendChild(titleDiv); if (item.children) createMenuHTML(item.children, li); } else { const itemDiv = document.createElement('div'); itemDiv.className = 'menu-item'; itemDiv.innerText = item.title; itemDiv.onclick = () => { document.querySelectorAll('.menu-item').forEach(el => el.classList.remove('active')); itemDiv.classList.add('active'); loadModel3D(item.file, item.title, item.desc); if (window.innerWidth <= 768) document.getElementById('sidebar').classList.remove('mobile-open'); }; li.appendChild(itemDiv); } ul.appendChild(li); }); parentElement.appendChild(ul);
        }
        if (typeof curriculumData !== 'undefined') { createMenuHTML(curriculumData, menuContainer); const firstSub = menuContainer.querySelector('.submenu'); if (firstSub) firstSub.classList.add('show'); } else { menuContainer.innerHTML = '<div style="padding:20px; color:red">‚ö†Ô∏è Ch∆∞a c√≥ d·ªØ li·ªáu menu_data.js!<br>H√£y ch·∫°y file Python scan_menu.py</div>'; }
        window.toggleMenu = function () { document.getElementById('sidebar').classList.toggle('mobile-open'); }
        document.getElementById('mobile-toggle').addEventListener('click', toggleMenu);
    </script>
</body>
</html>
